import com.github.jengelman.gradle.plugins.shadow.tasks.ShadowJar
import net.minecraftforge.gradleutils.PomUtils

plugins {
    id 'java'
    id 'maven-publish'
    id 'com.github.ben-manes.versions' version '0.50.0'
    id 'com.github.johnrengelman.shadow' version '8.1.1'
    id 'net.minecraftforge.gradleutils' version '[2.3,2.4)'
    id 'net.minecraftforge.licenser' version '1.0.1'
}

group = 'net.minecraftforge'
version = gradleutils.tagOffsetVersion
println "Version: $version"

java {
    toolchain {
        languageVersion = JavaLanguageVersion.of(8)
    }
    withSourcesJar()
}

repositories {
    mavenCentral()
    maven gradleutils.forgeMaven
}

dependencies {
    implementation(libs.bundles.asm)
    implementation(libs.jopt.simple)
    implementation(libs.gson)
    implementation(libs.guava)
    implementation(libs.nulls)

    testImplementation(libs.junit.api)
    testRuntimeOnly(libs.bundles.junit.runtime)
}

tasks.named('jar', Jar).configure {
    from(project.rootDir) {
        include 'LICENSE'
    }

    manifest {
        attributes([
            'Main-Class': 'net.minecraftforge.jarcompatibilitychecker.ConsoleTool',
            'Implementation-Version': project.version
        ])
    }
}

tasks.named('shadowJar', ShadowJar).configure {
    from(project.rootDir) {
        include 'LICENSE'
    }

    minimize()

    exclude 'META-INF/LICENSE.txt'
    exclude 'META-INF/versions/9/module-info.class'
}

tasks.named('assemble').configure {
    dependsOn 'shadowJar'
}

def getArtifacts(coord) {
    def udep = project.dependencies.create(coord)
    def cfg = project.configurations.detachedConfiguration(udep)
    cfg.setTransitive(true)
    def files = cfg.resolve()
    def ret = [
        main: null,
        libs: [:]
    ]

    cfg.resolvedConfiguration.resolvedArtifacts.each {
        def art = [
            group: it.moduleVersion.id.group,
            name: it.moduleVersion.id.name,
            version: it.moduleVersion.id.version,
            classifier: it.classifier,
            extension: it.extension,
            file: it.file
        ]

        def desc = "${art.group}:${art.name}:${art.version}"
        if (art.classifier != null)
            desc += ":${art.classifier}"
        if (art.extension != 'jar')
            desc += "@${art.extension}"

        if (coord == desc) {
            ret.main = art.file
        } else {
            ret.libs["${art.group}:${art.name}"] = [
                version: art.version,
                name: desc,
                file: art.file
            ]
        }
    }

    return ret
}

tasks.register('testLibrary').configure {
    dependsOn 'shadowJar'
    doFirst {
        def libs =
            //['cpw.mods:securejarhandler:2.1.10', 'net.minecraftforge:securemodules:2.2.2']
            ['net.minecraftforge:coremods:5.0.1', 'net.minecraftforge:coremods:5.1.2']
            //['cpw.mods:modlauncher:9.0.24', 'net.minecraftforge:modlauncher:10.1.1']
        def base = getArtifacts(libs[0])
        def input = getArtifacts(libs[1])

        def cmd = [
            tasks.named('shadowJar').get().archiveFile.get().asFile.absolutePath,
            '--quiet',
            '--api'
        ]
        base.libs.each { ga, lib ->
            cmd += ['--base-lib', lib.file.absolutePath]
        }
        input.libs.each { ga, lib ->
            cmd += ['--input-lib', lib.file.absolutePath]
        }

        logger.lifecycle(libs[0] + ' -> ' + libs[1])
        javaexec {
            ignoreExitValue = true
            main = '-jar'
            args = cmd + [
                '--base-jar', base.main.absolutePath,
                '--input-jar', input.main.absolutePath
            ]
        }

        base.libs.each { ga, lib ->
            def ilib = input.libs[ga]
            if (ilib == null) {
                logger.lifecycle('')
                logger.lifecycle("$ga: ${lib.version} -> removed")
            } else if (ilib.version != lib.version) {
                logger.lifecycle('')
                logger.lifecycle("$ga: ${lib.version} -> ${ilib.version}")
                javaexec {
                    ignoreExitValue = true
                    main = '-jar'
                    args = cmd + [
                        '--base-jar', lib.file.absolutePath,
                        '--input-jar', ilib.file.absolutePath
                    ]
                }
            }
        }
        input.libs.each { ga, lib ->
            if (base.libs[ga] == null) {
                logger.lifecycle('')
                logger.lifecycle("$ga: missing -> ${lib.version}")
            }
        }

         logger.lifecycle('')
    }
}

tasks.withType(JavaCompile).configureEach {
    options.encoding = 'UTF-8' // Use the UTF-8 charset for Java compilation
}

changelog {
    from '0.1'
}

license {
    header = file('LICENSE-header.txt')
    newLine = false
    include 'net/minecraftforge/jarcompatibilitychecker/**/*.java'
}

publishing {
    publications.register('mavenJava', MavenPublication) {
        from components.java

        pom {
            name = 'JAR Compatibility Checker'
            description = 'Reports API or binary incompatibilities between two JARs'
            url = 'https://github.com/MinecraftForge/JarCompatibilityChecker'

            PomUtils.setGitHubDetails(pom, 'JarCompatibilityChecker')

            license PomUtils.Licenses.LGPLv2_1

            developers {
                developer PomUtils.Developers.SizableShrimp
            }
        }
    }

    repositories {
        maven gradleutils.getPublishingForgeMaven()
    }
}
